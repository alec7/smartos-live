/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Copyright 2019 Joyent, Inc.
 */

/*
 * XXX
 * - This is perhaps overly simplistic.  We may want a boot service that
 *   populates some state in /var/run and normal users would read from one of
 *   the following:
 *
 *    - /var/run/features/features.d/   like loadFeatures works now
 *    - /var/run/features/features.js   a json cache that matches features.d
 *    - /var/run/features/features.sh   a bash/ksh cache that matches features.d
 *
 * - There should be a way for a CN to persist some overrides.  Maybe
 *   /var/features/features.d?
 * - It should be possible for boot-time service(s) to populate features. They
 *   should update /var/run/features.d/whatever, then 'svcadm refresh' the
 *   service that updates features.{js,sh}
 */
var fs = require('fs');
var path = require('path');
var sprintf = require('/usr/node/node_modules/sprintf').sprintf;
var vasync = require('/usr/vm/node_modules/vasync');

var feature_dir = '/etc/features.d';
var features = {};

var nolog = {
    'debug': function noDebug() {},
    'error': function noError() {}
};

/* XXX options.dirs array rather than a single dir? */
/* XXX should this replace the existing features object or augment it? */
function loadFeatures(options, callback) {
    var dir = options.dir || feature_dir;
    var log = options.log || nolog;

    log.debug('loadFeatures: reading configuration from ' + dir);

    try {
        var inputs = fs.readdirSync(dir).sort();
    } catch (e) {
        log.debug('loadFeatures: failed to read directory: ' + e.message);
        callback();
        return;
    }
    /*
     * The order that the files are read matters.  Settings in `99fixed` are
     * meant to be able to override those in `00broken`.
     */
    vasync.forEachPipeline({
        'inputs': inputs,
        'func': function readFeatureFile(fname, next) {
            fname = path.join(dir, fname);
            log.debug('Reading ' + fname);
            fs.readFile(fname, 'ascii', function doRead(err, data) {
                if (err) {
                    next(err);
                    return;
                }
                var lines = data.split('\n');
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    if (line === '' || line.match(/^#/)) {
                        continue;
                    }
                    var kv = line.split('=');
                    if (kv.length != 2) {
                        next(new Error(sprintf('%s:%d not key=value',
                            fname, i + 1)));
                        return;
                    }
                    if (['true', 'false'].indexOf(kv[1]) == -1) {
                        next(new Error(sprintf('%s:%d value not boolean',
                            fname, i + 1)));
                        return;
                    }
                    log.debug({path: fname, line: i + 1, feature: kv},
                        'loaded feature');
                    features[kv[0]] = kv[1] === 'true';
                }
                next();
            });
        }
    }, function doneReading(err) {
        if (err) {
            log.error({err: err}, 'loadFeature: failed');
        } else {
            log.debug({features: features}, 'loadFeature: succeeded');
        }
        callback(err);
    });
}

module.exports = {
    load: loadFeatures,
    feature: features
};
